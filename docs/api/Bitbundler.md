## Bitbundler(options) : Bitbundler

Contructor for creating instances of bit-bundler. The constructor itself takes several options which detailed below.

### options

#### **`multiprocess`** { boolean | number }

Option to enable parallel file processing via worker processes. By default, multiprocess is disabled. But you can enable multiprocess by setting this option to true, which will start two child processes. You can alternatively specify the number of processes to use with the max capped to the number of cpus available.

#### **`umd`** { string }

`UMD` name to be exported. `UMD` is a module format that allows bundles to run in nodejs and in the browser via requirejs and traditional script tags. Consider using this setting when writing libraries and utilities that are intended to run in the browser and nodejs. [This is some literature on it](https://github.com/umdjs/umd).

#### **`baseUrl`** { string } (process.cwd())

url used for when resolving the file path for modules that dont have an absolute path as in the case of node modules. This is particularly useful when bit-bundler should find node modules in a different directoy other than `process.cwd()`.

#### **`watch`** { boolean | object } (false)

Flag to enable file watching. You can optionally specify an object, in which case bit-bundler will simply forward it as options to [chokidar](https://github.com/paulmillr/chokidar) which is the underlying library for file watching. Please do checkout [chokidar](https://github.com/paulmillr/chokidar) options in order to understand what options are available.

#### **`stubNotFound`** { boolean } (false)

Enable to replace modules that are not found in storage with a stub module. This is necessary when a module isn't found in storage that is not needed for the bundle to properly execute. If the module isn't stubbed out in these cases then the bundle will fail to execute throwing an error that the particular module isn't found.

#### **`sourceMap`** { boolean } (true)

Toggle source map generation in the final bundle.

#### **`exportNames`** { boolean | string[] | object } (false)

Export modules by name when bundling node modules. The value can be boolean, in which case modules imported by name rathen than file path are exported by their name. The value can also be an array of names, which allows us to specify a more specific set of module names to export. And lastly, the value can be an object that maps module names to exported name. Meaning that module names that map to the key in the object is exported with the name defined as the value for the corresponding key.
The use case is for creating bundles that contain your 3rd party dependencies, which you are looking to import by name from your application bundle by calling `require("belty")` for example.

#### **`log`** { stream | { stream: WritableStream, level: string } } (buildstats)

By default bit-bundler uses the `buildstats` stream which logs warnings, errors, and build information. You can control the log level by specifying one of the following values `'info'`, `'warn'`, `'error'`.

  - **`stream`** { WritableStream } - Writable stream to write log messages to. There are several sample streams in the [loggers directory](https://github.com/MiguelCastillo/bit-bundler/tree/master/loggers).

  - **`level`** { string } - Log level to fine tune the severity of messages to be logged. Valid values are `'info'`, `'warn'`, `'error'`. Defaults to `warn`.

#### **`loader`** [ object[] | string[] | function[] ]

Plugins to be registerer with the module loader. These plugins are for loading and procesing modules before they are bundled.

  - **`object[]`** - When a plugin is an object with a `name` defined as a property, then that name is subsequently used for loading the plugin as a node module. The actual object is forwarded to the plugin module as its options. If the object does **not** have a `name` defined as a property, then the object is considered the actual plugin definition.

  - **`string[]`** - When a plugin is a string, then that's used as the name of a module that is subsequently loaded as a node module.

  - **`function[]`** - When a plugin is a function, then that function is called and expected to return a plugin definition.

#### **`bundler`** [ object[] | string[] | function[] ]

Plugins to be registered with the bundler to manipulate bundles. Plugins can be used for processing the module graph generated by the module loader.

> bundler plugins have the same configuration pattern as `loader` plugins.


## bundle(files) : Promise

Method generating bundles. `bundle` returns a promise that when resolved returns the bundling [context](#context).

#### **`files`**

File definition that contains what needs to be bundled and optionally the destination where bundles are written to. `files` can be any of the shapes below.

  - **`string[]`** - when files is a string or an array of strings, then those are the files that are bundled. These can be globs.

  - **`{ src: [], dest: string }`** - An object with a property named `src` that is the input to be bundled and an optionally `dest` property, which is the where the bundle is written to. `src` can be a string and array strings. When `src` contains strings, these can be globs that get resolved relative to the current working directory. `src` can also be an array of objects with string `content`, in which case bit-bundler will just bundle that. `src` array can also contain an object with a `path` in it, which will get resolved bit-bundler as the path of a module. `src` array can also contain an object with a module `name` in it, which will also get resolved by bit-bundler. Please see examples below to get a better understanding of defining `src`.

    - **`dest`** - can be a string, which is treated as the file name where the bundle is written to. dest can alternatively be a writable stream, which is the stream the bundle is written to.


Basic setup for bundling a file.

``` javascript
require("@bit/bundler").bundle(["path/to/file.js"]);
```

Bundle a module and specify the destination for the bundle.

``` javascript
const Bitbundler = require("@bit/bundler");

Bitbundler.bundle({
  src: ["path/to/file.js"],
  dest: "output/bundle.js"
});
```

The destination can be a stream

``` javascript
const Bitbundler = require("@bit/bundler");

Bitbundler.bundle({
  src: ["path/to/file.js"],
  dest: process.stdout
});
```

Bundle content. Notice the dependencies `./src/hello` and `./src/world`. These dependencies will get resolved (relative to the current working), processed, and bundled as expected.

``` javascript
const Bitbundler = require("@bit/bundler");

Bitbundler.bundle({
  dest: "dist/out.js",
  src: {
    content: `
      const hello = require("./src/hello");
      const world = require("./src/world");
      console.log(hello() + " + " + world());
    `
  }
});
```

Bundle content and some other module name.

``` javascript
const Bitbundler = require("@bit/bundler");

Bitbundler.bundle({
  dest: "dist/out.js",
  src: [{
      name: "belty"
    }, {
      content: `
        const hello = require("./src/hello");
        const world = require("./src/world");
        console.log(hello() + " + " + world());
      `
    }
  ]
});
```

You can also include globs along with other stuff you want to bundle

``` javascript
const Bitbundler = require("@bit/bundler");

Bitbundler.bundle({
  dest: "dist/out.js",
  src: [ "src/*.js", {
      name: "belty"
    }, {
      content: `
        const hello = require("./src/hello");
        const world = require("./src/world");
        console.log(hello() + " + " + world());
      `
    }
  ]
});
```
