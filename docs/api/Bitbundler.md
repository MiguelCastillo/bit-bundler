## Bitbundler(options) : Bitbundler

Contructor for creating instances of bit-bundler. The constructor itself takes several options which detailed below.

### options

#### **`multiprocess`** { boolean | number }

Option to enable parallel file processing via worker processes. By default, multiprocess is disabled. But you can enable multiprocess by setting this option to true. You can alternatively specify the number of processes to use with the max capped to the number of cpus available.

#### **`umd`** { string }

`UMD` name to be exported. `UMD` is a module format that allows bundles to run in nodejs and in the browser via requirejs and traditional script tags. Consider using this setting when writing libraries and utilities that are intended to run in the browser and nodejs. [This is some literature on it](https://github.com/umdjs/umd).

#### **`baseUrl`** { string } (process.cwd())

url used for when resolving the file path for modules that dont have an absolute path as in the case of node modules. This is particularly useful when bit-bundler should find node modules in a different directoy other than `process.cwd()`.

#### **`watch`** { boolean | object } (false)

Flag to enable file watching. You can optionally specify an object, in which case bit-bundler will simply forward it as options to [chokidar](https://github.com/paulmillr/chokidar) which is the underlying library for file watching. Please do checkout [chokidar](https://github.com/paulmillr/chokidar) options in order to understand what options are available.

#### **`stubNotFound`** { boolean } (false)

Enable to replace modules that are not found in storage with a stub module. This is necessary when a module isn't found in storage that is not needed for the bundle to properly execute. If the module isn't stubbed out in these cases then the bundle will fail to execute throwing an error that the particular module isn't found.

#### **`sourceMap`** { boolean } (true)

Toggle source map generation in the final bundle.

#### **`exportNames`** { boolean } (false)

Export modules by name when bundling node modules. The use case is for creating bundles that contain your 3rd party dependencies, which you are looking to import by name from your application bundle.

#### **`log`** { stream | { stream: WritableStream, level: string } } (buildstats)

By default bit-bundler uses the `buildstats` stream which logs warnings, errors, and build information. You can control the log level by specifying one of the following values `'info'`, `'warn'`, `'error'`.

  - **`stream`** { WritableStream } - Writable stream to write log messages to. There are several sample streams in the [loggers directory](https://github.com/MiguelCastillo/bit-bundler/tree/master/loggers).

  - **`level`** { string } - Log level to fine tune the severity of messages to be logged. Valid values are `'info'`, `'warn'`, `'error'`. Defaults to `warn`.

#### **`loader`** [ object[] | string[] | function[] ]

Plugins to be registerer with the module loader. These plugins are for loading and procesing modules before they are bundled.

  - **`object[]`** - When a plugin is an object with a `name` defined as a property, then that name is subsequently used for loading the plugin as a node module. The actual object is forwarded to the plugin module as its options. If the object does **not** have a `name` defined as a property, then the object is considered the actual plugin definition.

  - **`string[]`** - When a plugin is a string, then that's used as the name of a module that is subsequently loaded as a node module.

  - **`function[]`** - When a plugin is a function, then that function is called and expected to return a plugin definition.

#### **`bundler`** [ object[] | string[] | function[] ]

Plugins to be registered with the bundler to manipulate bundles. Plugins can be used for processing the module graph generated by the module loader.

> bundler plugins have the same configuration pattern as `loader` plugins.


## bundle(files) : Promise

Method to bundle a list of files. `bundle` returns a promise that when resolved returns the bundling [context](#context).

#### **`files`** { string[] | { string[] : src, string: dest } }

File definition that contains the files to be bundled, and optionally the destination where the bundle is written to. bit-bundler uses [src-dest](https://github.com/MiguelCastillo/src-dest) to handle file configuration parsing, so check it out if you need more details.

  - **`string[]`** - when files is a string or an array of strings, then those are the files that are bundled.

  - **`{ string[]: src, string: dest }`** - When files is an object, then it is expected to contain an `src` property defined in it which can either be a string of an array of strings; and these are the files that are bundled. The file object can optionally contain a `dest` property defined in it, which is the where the bundle is written to.

    - **`dest`** - can be a string, which is treated as the file name where the bundle is written to. dest can alternatively be a writable stream, which is the stream the bundle is written to.


Basic setup for bundling a file.

``` javascript
const Bitbundler = require("bit-bundler");
const bitbundler = new Bitbundler();

bitbundler.bundle(["path/to/file.js"]);
```

You can specify the destination of the bundle.

``` javascript
const Bitbundler = require("bit-bundler");
const bitbundler = new Bitbundler();

bitbundler.bundle({
  src: ["path/to/file.js"],
  dest: "output/bundle.js"
});
```

Destination can be a stream
``` javascript
const Bitbundler = require("bit-bundler");
const bitbundler = new Bitbundler();

bitbundler.bundle({
  src: ["path/to/file.js"],
  dest: process.stdout
});
```
