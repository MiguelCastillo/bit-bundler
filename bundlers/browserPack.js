var browserPack = require("browser-pack");
var getUniqueId = require("./getUniqueId");
var pstream = require("p-stream");
var utils = require("belty");


function browserPackBundler(bundler, modules) {
  if (!modules.length) {
    return Promise.resolve();
  }

  var bpBundle = toBrowserPackModules(bundler, modules);
  var bpOptions = configureBrowserPack(bundler, bpBundle);

  // Print bundle information
  if (bundler._options.showInformation) {
    printBundleInformation(bpBundle, bpOptions);
  }

  return writeBrowserPackModules(bpBundle.modules, bpOptions)
    .then(function(result) {
      bpBundle.result = result;
      return bpBundle;
    });
}


/**
 * Creates browser pack settings.
 *
 * @param {Bundler} bundler - Bundler instance to build browser pack settings from
 * @param {Object} bundles - Browser pack bundles
 *
 * @returns {Object} Browser pack settings.
 */
function configureBrowserPack(bundler, bundle) {
  var bpOptions = utils.merge({}, bundler._options.browserPack);

  if (bpOptions.standalone) {
    bpOptions.standaloneModule = bundle.exports;
  }

  return bpOptions;
}


/**
 * Converts modules from bit loader to browser pack
 *
 * @param {Bundler} bundler - Instance of the bundler
 * @param {Module[]} modules - Collection of modules generated by bit loader to be converted
 *  to browser pack compatible modules
 *
 * @return {Object[]} Collection of browser pack bundles
 */
function toBrowserPackModules(bundler, modules) {
  return createBundle(bundler, modules, bundler._options.splitVendor);
}


function createBundle(bundler, modules, splitVendor) {
  var bpMod;
  var loader = bundler._loader;
  var stack = modules.slice(0);
  var cache = {};
  var result = {
    modules: [],
    exports: [],
    vendor: []
  };

  while(stack.length) {
    id = stack.pop().id;

    if (cache.hasOwnProperty(id)) {
      continue;
    }

    mod = loader.getModule(id);
    bpMod = createBrowserPackModule(bundler, mod);

    if (splitVendor && bpMod.vendor) {
      result.vendor.push({
        id: mod.id,
        name: mod.name,
        path: mod.path
      });
    }
    else {
      result.modules.push(bpMod);
      stack = stack.concat(mod.deps);
    }

    cache[mod.id] = bpMod;
  }

  modules.forEach(function(mod) {
    cache[mod.id].entry = true;
    result.exports.push(cache[mod.id].id);
  });

  return result;
}


function createBrowserPackModule(bundler, mod) {
  var getId = bundler._options.filePathAsId ? utils.noop : getUniqueId;

  // browser pack mod
  var bpMod = {
    id     : getId(mod.id),
    name   : mod.name,
    path   : mod.path,
    source : mod.source,
    deps   : {},
    entry  : false,
    vendor : /^\w+/.test(mod.name)
  };

  var i, length, dep;
  for (i = 0, length = mod.deps.length; i < length; i++) {
    dep = mod.deps[i];
    bpMod.deps[dep.name] = getId(dep.id);
  }

  return bpMod;
}


/**
 * Generate bundle with browser pack
 *
 * @param {Object[]} bundles - Collection of browser pack modules to be processed
 *  by browser pack
 * @param {Object} options - Browser pack options
 *
 * @returns {Promise} That when resolved will provide the generated bundle as a string
 */
function writeBrowserPackModules(bundle, options) {
  var bp = browserPack(options);
  var deferred = pstream(bp);

  bundle.forEach(function(mod) {
    bp.write(mod);
  });

  bp.end();
  return deferred;
}


function printBundleInformation(bundle, options) {
  var output = {
    modules: []
  };

  if (options.standalone) {
    output.standalone = options.standalone;
    output.exports = bundle.exports;
  }

  bundle.modules.forEach(function(mod) {
    output.modules.push({
      id: mod.id,
      name: mod.name,
      path: mod.path,
      deps: JSON.stringify(mod.deps)
    });
  });

  console.log(output);
}


module.exports = browserPackBundler
