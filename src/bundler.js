var browserPack = require("browser-pack");
var pstream = require("p-stream");
var types = require("dis-isa");
var utils = require("belty");
var getUniqueId = require("./getUniqueId");
var builtInsProcessor = require("./builtInsProcessor");


function Bundler(loader, options) {
  this._loader = loader;
  this._files = [];
  this._options = {};
  this._bundle = browserPackBundler;

  if (options.builtin !== false) {
    this.resolve(builtInsProcessor.resolve);
    this.transform(builtInsProcessor.transform);
  }

  this.configure(options);
}


Bundler.prototype.configure = function(options) {
  var bundler = this;

  Object.keys(options)
    .filter(function(option) {
      return types.isFunction(bundler[option]);
    })
    .forEach(function(option) {
      bundler[option](options[option]);
    });

  this._options = utils.merge({}, this._options, options);
  return this;
};


Bundler.prototype.files = function(files) {
  if (!files) {
    throw new TypeError("Files is a required argument");
  }

  if (types.isString(files)) {
    files = [files];
  }

  this._files = this._files.concat(files); // I like that we have a new array.
  return this;
};


Bundler.prototype.ignore = function(config) {
  this._loader.ignore(config);
  return this;
};


Bundler.prototype.resolve = function(config) {
  this._loader.plugin("bundler", {
    resolve: config
  });

  return this;
};


Bundler.prototype.fetch = function(config) {
  this._loader.plugin("bundler", {
    fetch: config
  });

  return this;
};


Bundler.prototype.transform = function(config) {
  this._loader.plugin("bundler", {
    transform: config
  });

  return this;
};


Bundler.prototype.dependency = function(config) {
  this._loader.plugin("bundler", {
    dependency: config
  });

  return this;
};


Bundler.prototype.bundle = function(files) {
  files = files || this._files;

  if (!files) {
    throw new TypeError("Must provide Files to bundle");
  }

  return this._loader.fetch(files).then(runBundler(this));
};


function runBundler(bundler) {
  return function runBundlerDelegate(modules) {
    var bundle = bundler._options.bundle ? bundler._options.bundle : bundler._bundle;
    return Promise.resolve(bundle(bundler, modules));
  };
}


function browserPackBundler(bundler, modules) {
  var bpBundle = toBrowserPackModules(bundler, modules);
  var bpOptions = configureBrowserPack(bundler, bpBundle);

  // Print bundle information
  if (bundler._options.showInformation) {
    printBundleInformation(bpBundle, bpOptions);
  }

  return writeBrowserPackModules(bpBundle.modules, bpOptions)
    .then(function(result) {
      bpBundle.result = result;
      return bpBundle;
    });
}


/**
 * Creates browser pack settings.
 *
 * @param {Bundler} bundler - Bundler instance to build browser pack settings from
 * @param {Object} bundles - Browser pack bundles
 *
 * @returns {Object} Browser pack settings.
 */
function configureBrowserPack(bundler, bundle) {
  var bpOptions = utils.merge({}, bundler._options.browserPack);

  if (bpOptions.standalone) {
    bpOptions.standaloneModule = bundle.exports;
  }

  return bpOptions;
}


/**
 * Converts modules from bit loader to browser pack
 *
 * @param {Bundler} bundler - Instance of the bundler
 * @param {Module[]} modules - Collection of modules generated by bit loader to be converted
 *  to browser pack compatible modules
 *
 * @return {Object[]} Collection of browser pack bundles
 */
function toBrowserPackModules(bundler, modules) {
  return createBundle(bundler, modules, bundler._options.splitVendor);
}


function createBundle(bundler, modules, splitVendor) {
  var bpMod;
  var loader = bundler._loader;
  var stack = modules.slice(0);
  var cache = {};
  var result = {
    modules: [],
    exports: [],
    vendor: []
  };

  while(stack.length) {
    id = stack.pop().id;

    if (cache.hasOwnProperty(id)) {
      continue;
    }

    mod = loader.getModule(id);
    bpMod = createBrowserPackModule(bundler, mod);

    if (splitVendor && bpMod.vendor) {
      result.vendor.push({
        id: mod.id,
        name: mod.name,
        path: mod.path
      });
    }
    else {
      result.modules.push(bpMod);
      stack = stack.concat(mod.deps);
    }

    cache[mod.id] = bpMod;
  }

  modules.forEach(function(mod) {
    cache[mod.id].entry = true;
    result.exports.push(cache[mod.id].id);
  });

  return result;
}


function createBrowserPackModule(bundler, mod) {
  var getId = bundler._options.filePathAsId ? utils.noop : getUniqueId;

  // browser pack mod
  var bpMod = {
    id     : getId(mod.id),
    name   : mod.name,
    path   : mod.path,
    source : mod.source,
    deps   : {},
    entry  : false,
    vendor : /^\w+/.test(mod.name)
  };

  var i, length, dep;
  for (i = 0, length = mod.deps.length; i < length; i++) {
    dep = mod.deps[i];
    bpMod.deps[dep.name] = getId(dep.id);
  }

  return bpMod;
}


/**
 * Generate bundle with browser pack
 *
 * @param {Object[]} bundles - Collection of browser pack modules to be processed
 *  by browser pack
 * @param {Object} options - Browser pack options
 *
 * @returns {Promise} That when resolved will provide the generated bundle as a string
 */
function writeBrowserPackModules(bundle, options) {
  var bp = browserPack(options);
  var deferred = pstream(bp);

  bundle.forEach(function(mod) {
    bp.write(mod);
  });

  bp.end();
  return deferred;
}


function printBundleInformation(bundle, options) {
  var output = {
    modules: []
  };

  if (options.standalone) {
    output.standalone = options.standalone;
    output.exports = bundle.exports;
  }

  bundle.modules.forEach(function(mod) {
    output.modules.push({
      id: mod.id,
      name: mod.name,
      deps: JSON.stringify(mod.deps)
    });
  });

  console.log(output);
}


module.exports = Bundler;
